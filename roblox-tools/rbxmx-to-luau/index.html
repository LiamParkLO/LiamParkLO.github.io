<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RBXMX to LuaU Converter</title>
<style>
  body { font-family: monospace; padding: 20px; background: #222; color: #eee; }
  #code { width: 100%; height: 300px; margin-top: 10px; background: #111; color: #0f0; border: none; padding: 10px; }
  #console { display: block; margin-top: 10px; color: #f55; white-space: pre-wrap; }
  button, input[type="file"] { margin-top: 10px; }
</style>
</head>
<body>

<input type="file" id="file" accept=".rbxmx,.xml" />
<button id="convert">Convert</button>
<strong id="console"></strong>
<textarea id="code" readonly></textarea>

<script>
(() => {
  const fileInput = document.getElementById('file');
  const convertBtn = document.getElementById('convert');
  const consoleEl = document.getElementById('console');
  const codeEl = document.getElementById('code');

  // Roblox Services list for direct referencing
  const SERVICES = new Set([
    'Workspace', 'ServerScriptService', 'ServerStorage', 'StarterPlayer', 'Teams',
    'ReplicatedFirst', 'ReplicatedStorage', 'StarterPack', 'StarterGui', 'Lighting',
    'SoundService', 'Chat', 'LocalizationService', 'TestService', 'UserInputService',
    'HttpService', 'RunService', 'ContextActionService', 'PhysicsService',
    'CollectionService', 'MessagingService', 'TextService', 'TeleportService',
    'TweenService', 'GuiService', 'BadgeService', 'InsertService', 'AssetService',
    'ContentProvider', 'PathfindingService', 'AnalyticsService', 'DataStoreService',
    'VoiceChatService', 'AccessibilityService'
  ]);

  // Properties to skip from serialization
  const skipProps = new Set([
    'AttributesSerialize', 'Color3uint8', 'MaterialColors', 'PhysicsGrid', 'SmoothGrid', 'BinaryString'
  ]);

  // Helper function to escape string literals
  function escapeString(str) {
    return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '');
  }

  // Parse XML string to DOM
  function parseXML(str) {
    return new DOMParser().parseFromString(str, 'application/xml');
  }

  // Convert string to Lua literal
  function toLuaLiteral(value, type) {
    if (type === 'bool') return value === 'true' ? 't' : 'f';
    if (type === 'int' || type === 'float') return value;
    if (type === 'token') return `"${value}"`;
    if (type === 'string') return `"${escapeString(value)}"`;
    if (type === 'UDim2') {
      const parts = value.split(' ');
      if (parts.length === 4) return `v3(${parts.join(',')})`;
    }
    if (type === 'Vector2') {
      const parts = value.split(' ');
      if (parts.length === 2) return `v2(${parts.join(',')})`;
    }
    if (type === 'BrickColor') {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1 && num <= 1032) return `v4(${num})`;
    }
    if (type === 'CFrame') {
      const parts = value.trim().split(/\s+/);
      if (parts.length === 12) return `v5(${parts.join(',')})`;
      if (parts.length === 3) return `v5(${parts.join(',')})`; // Position only
    }
    return `"${escapeString(value)}"`;
  }

  // Generate Lua code recursively
  function generateLua(inst, parentName, idx = 1) {
    const className = inst.getAttribute('class');
    if (!className) return '';

    if (className === 'undefined') return '';

    // Variable name for instance
    const varName = `${parentName}${idx}`;

    let code = '';

    // Handle services
    if (SERVICES.has(className)) {
      code += `local ${varName} = game:GetService("${className}")\n`;
    } else if (className === 'Terrain') {
      // Special case Terrain: direct property assignments, no Instance.new
      code += `local ${varName} = workspace.Terrain\n`;
    } else {
      code += `local ${varName} = v1("${className}")\n`;
    }

    // Loop through properties
    for (let prop of inst.children) {
      if (skipProps.has(prop.tagName)) continue;
      const propName = prop.tagName;
      if (propName === 'Properties') continue; // skip wrapper node if any

      // Property type & value node
      const type = prop.getAttribute('type');
      const value = prop.textContent || '';

      if (!value) continue;
      if (propName === 'BinaryString') continue;

      // Fix bug where property tag is same as type or invalid
      // Use propName as property

      // Convert value to Lua literal based on type
      const luaValue = toLuaLiteral(value.trim(), type);

      if (luaValue === undefined) continue;

      code += `v6(function() ${varName}.${propName} = ${luaValue} end)\n`;
    }

    // Recurse children
    let childIdx = 1;
    for (let child of inst.children) {
      if (child.tagName === 'Properties') continue; // skip properties node
      if (child.tagName === 'BinaryString') continue;
      if (child.tagName === 'AttributesSerialize') continue;

      // Only consider nodes with 'class' attribute as instances
      if (child.hasAttribute && child.hasAttribute('class')) {
        code += generateLua(child, varName, childIdx);
        code += `v6(function() ${generateAddChild(varName, `${varName}${childIdx}`)} end)\n`;
        childIdx++;
      }
    }

    return code;
  }

  // Helper to add child: parent.Child = child or parent:AddChild(child)
  function generateAddChild(parentVar, childVar) {
    // In Roblox Lua, child.Parent = parent
    return `${childVar}.Parent = ${parentVar}`;
  }

  // Main conversion function
  async function convertFile(file) {
    consoleEl.textContent = '';
    codeEl.value = '';

    const text = await file.text();
    let xmlDoc;
    try {
      xmlDoc = parseXML(text);
      const parseError = xmlDoc.querySelector('parsererror');
      if (parseError) throw new Error(parseError.textContent);
    } catch (e) {
      consoleEl.textContent = 'XML Parse Error: ' + e.message;
      return;
    }

    // Root Instance
    const root = xmlDoc.documentElement;
    if (!root || root.tagName !== 'roblox') {
      consoleEl.textContent = 'Invalid RBXMX file: missing <roblox> root';
      return;
    }

    // Usually first child is Instance
    let instanceNode = null;
    for (const child of root.children) {
      if (child.tagName === 'Item' && child.getAttribute('class')) {
        instanceNode = child;
        break;
      }
    }
    if (!instanceNode) {
      // fallback to first element with class attribute
      instanceNode = root.querySelector('[class]');
      if (!instanceNode) {
        consoleEl.textContent = 'No instance found in RBXMX';
        return;
      }
    }

    // Begin code output
    let output = `local v1,v2,v3,v4,v5,v6,t,f=Instance.new,Vector2.new,UDim2.new,BrickColor.new,CFrame.new,pcall,true,false\n`;

    try {
      output += generateLua(instanceNode, 'unnamed');
    } catch (e) {
      consoleEl.textContent = 'Conversion error: ' + e.message;
      return;
    }

    codeEl.value = output;
  }

  convertBtn.addEventListener('click', () => {
    const file = fileInput.files[0];
    if (!file) {
      consoleEl.textContent = 'Please select a .rbxmx file first.';
      return;
    }
    convertFile(file);
  });
})();
</script>

</body>
</html>
