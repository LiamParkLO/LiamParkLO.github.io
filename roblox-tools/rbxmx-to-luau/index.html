<!DOCTYPE html>
<html>
<head>
  <title>Rojo Repo to LuaU Converter</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    textarea { width: 100%; height: 300px; margin-top: 1em; }
    #console { color: red; margin-top: 1em; font-weight: bold; display: block; }
  </style>
</head>
<body>
  <h1>Rojo Repo to LuaU Converter</h1>
  <input placeholder="GitHub Username" id="user">
  <input placeholder="Repository Name" id="repo">
  <button id="convert">Convert</button>
  <strong id="console"></strong>
  <textarea id="code" readonly></textarea>

  <script>
    const skipProps = ["AttributesSerialize", "Color3uint8", "MaterialColors", "PhysicsGrid", "Tags", "Version", "LinkedSource", "ScriptGuid", "SmoothGrid"];
    const nonCreatable = new Set(["Workspace", "Players", "Lighting", "ReplicatedFirst", "ReplicatedStorage", "ServerScriptService", "ServerStorage", "StarterGui", "StarterPack", "StarterPlayer", "Teams", "SoundService", "Chat", "LocalizationService", "TestService", "RunService", "HttpService", "TweenService", "Terrain", "TextService", "LogService", "InsertService", "ContentProvider", "PathfindingService", "CollectionService", "MemoryStoreService", "MessagingService"]);
    let varcount = 1;
    const varMap = new Map();

    document.getElementById("convert").addEventListener("click", async () => {
      const user = document.getElementById("user").value;
      const repo = document.getElementById("repo").value;
      const consoleOut = document.getElementById("console");
      const output = document.getElementById("code");
      if (!user || !repo) return consoleOut.textContent = "Missing user or repo";
      try {
        const zipUrl = `https://github.com/${user}/${repo}/archive/refs/heads/master.zip`;
        const res = await fetch(zipUrl);
        if (!res.ok) throw new Error("Repo fetch failed");
        const blob = await res.blob();
        const zip = await JSZip.loadAsync(blob);
        const tree = {};

        for (const [path, file] of Object.entries(zip.files)) {
          const parts = path.split("/").slice(1); // skip base folder
          let node = tree;
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (i === parts.length - 1) {
              if (!file.dir) {
                node[part] = await file.async("string");
              }
            } else {
              node = node[part] = node[part] || {};
            }
          }
        }

        if (!tree["default.project.json"]) throw new Error("Missing default.project.json");
        const project = JSON.parse(tree["default.project.json"]);
        validateProject(project, tree);

        let result = "-- generated from Rojo project by LiamPark_2021's tool\n\n";
        result += 'local v1,v2,v3,v4,v5=Instance.new,Vector2.new,UDim2.new,BrickColor.new,CFrame.new\nlocal v6=pcall local t,f=true,false\nfunction v7(obj, prop, token)\n    return Enum[tostring(obj[prop]):split(".")[2]][token+1]\nend\n\n';

        const convertTree = async (node, parentVar, indent = "") => {
          const varName = parentVar || "game";
          for (const [key, value] of Object.entries(node)) {
            if (key.startsWith("$")) continue;
            const className = value["$className"] || "Folder";
            const itemVar = sanitizeName(key) + (varcount++);
            if (nonCreatable.has(className)) {
              result += `${indent}local ${itemVar}=game:GetService("${className}")\n`;
            } else {
              result += `${indent}local ${itemVar}=v1("${className}")\n`;
            }
            if (value["$path"] && tree[value["$path"]]) {
              const rbxmxXml = new DOMParser().parseFromString(tree[value["$path"]], "text/xml");
              const rbxItem = rbxmxXml.querySelector("roblox > Item");
              result += walk(rbxItem, "");
              result += `v6(function() ${varMap.get(rbxItem)}.Parent=${itemVar} end)\n`;
            }
            if (value["$properties"]) {
              for (const [propName, val] of Object.entries(value["$properties"])) {
                if (typeof val === "string") result += `${indent}${itemVar}.${propName}=${JSON.stringify(val)}\n`;
                else if (typeof val === "boolean") result += `${indent}${itemVar}.${propName}=${val ? "t" : "f"}\n`;
                else if (Array.isArray(val)) result += `${indent}${itemVar}.${propName}=Color3.new(${val.join(",")})\n`;
                else result += `${indent}${itemVar}.${propName}=${val}\n`;
              }
            }
            result += `${indent}${itemVar}.Parent=${varName}\n`;
            await convertTree(value, itemVar, indent);
          }
        };

        await convertTree(project.tree);

        consoleOut.textContent = "";
        output.value = result.trim();
      } catch (err) {
        consoleOut.textContent = "Error: " + err.message;
        output.value = "";
      }
    });

    function sanitizeName(name) {
      return name.replace(/[^a-zA-Z0-9_]/g, "_");
    }

    function validateProject(project, tree) {
      if (!project.tree) throw new Error("Missing 'tree' in project");
      const missing = [];
      const checkPaths = (node) => {
        for (const key in node) {
          const item = node[key];
          if (item && typeof item === "object") {
            if (item["$path"] && !tree[item["$path"]]) missing.push(item["$path"]);
            else checkPaths(item);
          }
        }
      };
      checkPaths(project.tree);
      if (missing.length) throw new Error("Missing required files: " + missing.join(", "));
    }

    function walk(item, indent = "") {
      const className = item.getAttribute("class");
      const baseName = sanitizeName(item.getAttribute("name") || "unnamed");
      const varName = baseName + varcount++;
      varMap.set(item, varName);
      let code = "";
      if (className === "Terrain") {
        code += `${indent}local ${varName}=workspace.Terrain\n`;
      } else if (nonCreatable.has(className)) {
        code += `${indent}local ${varName}=game:GetService("${className}")\n`;
      } else {
        code += `${indent}local ${varName}=v1("${className}")\n`;
      }
      const props = Array.from(item.querySelector("Properties")?.children || []);
      const lines = parseProps(props, varName);
      for (const line of lines) code += `${indent}${line}\n`;
      const children = item.querySelectorAll(":scope > Item");
      for (const child of children) {
        code += walk(child, indent);
        const childVar = varMap.get(child);
        code += `${indent}v6(function() ${childVar}.Parent=${varName} end)\n`;
      }
      return code;
    }

    function parseProps(props, varName) {
      const lines = [];
      for (const prop of props) {
        const name = prop.getAttribute("name");
        if (skipProps.includes(name)) continue;
        const text = prop.textContent.trim();
        switch (prop.tagName) {
          case "string":
          case "ProtectedString":
            lines.push(`v6(function() ${varName}.${name}=${JSON.stringify(text)} end)`);
            break;
          case "bool":
            lines.push(`v6(function() ${varName}.${name}=${text === "true" ? "t" : "f"} end)`);
            break;
          case "int":
          case "float":
          case "double":
            lines.push(`v6(function() ${varName}.${name}=${text} end)`);
            break;
          case "token":
            lines.push(`v6(function() ${varName}.${name}=v7(${varName}, "${name}", ${Number(text)}) end)`);
            break;
          case "Vector2": {
            const [x2, y2] = text.split(/\s+/).map(Number);
            lines.push(`v6(function() ${varName}.${name}=v2(${x2},${y2}) end)`);
            break;
          }
          case "UDim2": {
            const [sx, ox, sy, oy] = text.split(/\s+/).map(Number);
            lines.push(`v6(function() ${varName}.${name}=v3(${sx},${ox},${sy},${oy}) end)`);
            break;
          }
          case "BrickColor":
            lines.push(`v6(function() ${varName}.${name}=v4(${Number(text)}) end)`);
            break;
          case "CoordinateFrame": {
            const nums = text.split(/\s+/).map(Number).filter(n => !isNaN(n));
            if (nums.length >= 3) lines.push(`v6(function() ${varName}.${name}=v5(${nums.join(",")}) end)`);
            break;
          }
          default:
            break;
        }
      }
      return lines;
    }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
