<!DOCTYPE html>
<html>
<head>
  <title>RBXMX to LuaU Converter (GitHub Repo)</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    textarea { width: 100%; height: 300px; margin-top: 1em; }
    #console { color: red; margin-top: 1em; font-weight: bold; display: block; }
    input { margin: 0.2em 0; }
  </style>
</head>
<body>
  <h1>RBXMX to LuaU Converter (GitHub Repo)</h1>
  <label>GitHub User: <input type="text" id="user" placeholder="User or org"></label><br>
  <label>Repository: <input type="text" id="repo" placeholder="Repo name"></label><br>
  <label>Branch (optional): <input type="text" id="branch" placeholder="Branch, default tries main then master"></label><br>
  <button id="convert">Convert Repo</button>
  <strong id="console"></strong>
  <textarea id="code" readonly></textarea>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    // --- Constants ---
    const skipProps = [
      "AttributesSerialize", "Color3uint8", "MaterialColors",
      "PhysicsGrid", "Tags", "Version", "LinkedSource", "ScriptGuid",
      "SmoothGrid"
    ];

    const nonCreatable = new Set([
      "Workspace", "Players", "Lighting", "ReplicatedFirst", "ReplicatedStorage",
      "ServerScriptService", "ServerStorage", "StarterGui", "StarterPack",
      "StarterPlayer", "Teams", "SoundService", "Chat", "LocalizationService",
      "TestService", "RunService", "HttpService", "TweenService", "Terrain",
      "TextService", "LogService", "InsertService", "ContentProvider",
      "PathfindingService", "CollectionService", "MemoryStoreService", "MessagingService"
    ]);

    // --- Globals ---
    let varcount = 1;
    const varMap = new Map();

    document.getElementById("convert").addEventListener("click", async () => {
      const user = document.getElementById("user").value.trim();
      const repo = document.getElementById("repo").value.trim();
      const branchInput = document.getElementById("branch").value.trim();

      const consoleOut = document.getElementById("console");
      const output = document.getElementById("code");

      consoleOut.textContent = "";
      output.value = "";

      if (!user || !repo) {
        consoleOut.textContent = "Please enter GitHub user and repo.";
        return;
      }

      try {
        consoleOut.textContent = "Fetching repo zip...";
        const zipData = await fetchRepoZip(user, repo, branchInput);

        consoleOut.textContent = "Reading zip...";
        const zip = await JSZip.loadAsync(zipData);

        // Convert zip files to {filename: content} nested structure
        const files = {};
        for (const [fullPath, zipEntry] of Object.entries(zip.files)) {
          if (zipEntry.dir) continue;
          // GitHub zips always have a root folder "repo-branchname/"
          const pathParts = fullPath.split("/").slice(1); // strip root folder
          setDeep(files, pathParts, await zipEntry.async("text"));
        }

        consoleOut.textContent = "Validating rojo project...";
        validateRojoProject(files);

        consoleOut.textContent = "Converting RBXMX to LuaU...";
        varcount = 1;
        varMap.clear();

        // Convert according to rojo tree
        // Load default.project.json to get tree structure
        const defaultProjStr = files["default.project.json"];
        const defaultProj = JSON.parse(defaultProjStr);

        const tree = defaultProj.tree;
        let result = "--[\ngenerated by liampark_2021's open source .rbxmx to luau converter.\n]\n\n";
        result += 'local v1,v2,v3,v4,v5=Instance.new,Vector2.new,UDim2.new,BrickColor.new,CFrame.new\nlocal v6=pcall local t,f=true,false\nfunction v7(obj, prop, token)\n    return Enum[tostring(obj[prop]):split(".")[2]][token+1]\nend\n\n';

        result += await walkTree(tree, files, "");

        consoleOut.textContent = "";
        output.value = result.trim();

      } catch (e) {
        consoleOut.textContent = "Error: " + e.message;
        output.value = "";
      }
    });

    // --- Helpers ---

    async function fetchRepoZip(user, repo, branchInput) {
      const branchesToTry = branchInput ? [branchInput] : ["main", "master"];
      for (const branch of branchesToTry) {
        const url = `https://github.com/${user}/${repo}/archive/refs/heads/${branch}.zip`;
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`Failed to fetch branch '${branch}', status ${res.status}`);
          return await res.arrayBuffer();
        } catch {
          // try next
        }
      }
      throw new Error(`Could not fetch any branch (${branchesToTry.join(", ")}) for ${user}/${repo}`);
    }

    // Recursive helper to set nested keys in object
    function setDeep(obj, keys, value) {
      if (keys.length === 1) {
        obj[keys[0]] = value;
        return;
      }
      if (!obj[keys[0]]) obj[keys[0]] = {};
      setDeep(obj[keys[0]], keys.slice(1), value);
    }

    // Validates default.project.json and referenced files exist
    function validateRojoProject(files) {
      if (!files["default.project.json"]) {
        throw new Error("Missing default.project.json in repo root");
      }
      const proj = JSON.parse(files["default.project.json"]);
      if (!proj.tree) throw new Error("default.project.json missing 'tree' property");

      // Recursively check tree paths
      function checkTreePaths(tree) {
        for (const key in tree) {
          if (key === "$className" || key === "$properties" || key === "$ignoreUnknownInstances") continue;
          const node = tree[key];
          if (typeof node === "object") {
            if (node["$path"]) {
              // Must exist in files
              if (!lookupPathInFiles(files, node["$path"])) {
                throw new Error(`File '${node["$path"]}' referenced in default.project.json is missing`);
              }
            }
            checkTreePaths(node);
          }
        }
      }
      checkTreePaths(proj.tree);
    }

    // Looks up path inside files object (nested)
    function lookupPathInFiles(files, path) {
      const parts = path.split(/[\/\\]/);
      let cur = files;
      for (const p of parts) {
        if (!cur[p]) return false;
        cur = cur[p];
      }
      return typeof cur === "string"; // must be file content string
    }

    // Recursively walks rojo tree and generates luau code
    async function walkTree(tree, files, indent) {
      let code = "";
      for (const key in tree) {
        if (key === "$className" || key === "$properties" || key === "$ignoreUnknownInstances") continue;
        const node = tree[key];

        const className = node["$className"];
        const path = node["$path"];
        const ignoreUnknownInstances = node["$ignoreUnknownInstances"];

        // Generate variable name
        const safeName = sanitizeName(key);
        const varName = safeName + varcount++;
        varMap.set(key, varName);

        if (path) {
          // It's a file reference (rbxmx or script folder)
          if (path.endsWith(".rbxmx")) {
            const rbxmxText = lookupPathContent(files, path);
            code += await convertRbxmxToLuau(rbxmxText, varName, indent);
          } else {
            // For folder paths (like src/server), we skip actual contents (not supported here)
            code += `${indent}-- Skipping folder path: ${path}\n`;
          }
        } else if (className) {
          // Direct Roblox instance creation
          if (className === "Terrain") {
            code += `${indent}local ${varName}=workspace.Terrain\n`;
          } else if (nonCreatable.has(className)) {
            code += `${indent}local ${varName}=game:GetService("${className}")\n`;
          } else {
            code += `${indent}local ${varName}=Instance.new("${className}")\n`;
          }

          // Set properties
          if (node["$properties"]) {
            for (const [prop, val] of Object.entries(node["$properties"])) {
              code += `${indent}pcall(function() ${varName}.${prop}=${formatValue(val)} end)\n`;
            }
          }

          // Recursively descend children
          code += await walkTree(node, files, indent);

          // Set parent
          code += `${indent}pcall(function() ${varName}.Parent=workspace end)\n`;

        }
      }
      return code;
    }

    // Helper to get file content string from files nested object
    function lookupPathContent(files, path) {
      const parts = path.split(/[\/\\]/);
      let cur = files;
      for (const p of parts) {
        cur = cur[p];
        if (!cur) throw new Error(`File not found in files: ${path}`);
      }
      if (typeof cur !== "string") throw new Error(`File content is not string: ${path}`);
      return cur;
    }

    // Convert RBXMX XML string to Luau code for a given variable name
    async function convertRbxmxToLuau(xmlText, varName, indent = "") {
      // Use DOMParser to parse RBXMX XML
      const parser = new DOMParser();
      const xml = parser.parseFromString(xmlText, "text/xml");
      const root = xml.querySelector("roblox");
      if (!root) throw new Error("Invalid RBXMX file");

      // Re-use your existing parsing logic with some adaptation:
      // We'll flatten items in root > Item
      const items = root.querySelectorAll(":scope > Item");
      let code = "";

      for (const item of items) {
        code += walkItem(item, varName, indent);
      }

      return code;
    }

    // Walk single RBXMX Item node, generate Luau code - adapted for varName base parent
    function walkItem(item, parentVar, indent = "") {
      const className = item.getAttribute("class");
      const baseName = sanitizeName(item.getAttribute("name") || "unnamed");
      const varName = baseName + varcount++;
      varMap.set(item, varName);

      let code = "";

      if (className === "Terrain") {
        code += `${indent}local ${varName}=workspace.Terrain\n`;
      } else if (nonCreatable.has(className)) {
        code += `${indent}local ${varName}=game:GetService("${className}")\n`;
      } else {
        code += `${indent}local ${varName}=Instance.new("${className}")\n`;
      }

      // Properties
      const props = Array.from(item.querySelector("Properties")?.children || []);
      const lines = parseProps(props, varName);
      for (const line of lines) code += indent + line + "\n";

      // Parent assignment
      code += `${indent}pcall(function() ${varName}.Parent=${parentVar} end)\n`;

      // Children
      const children = item.querySelector("Item") ? item.querySelectorAll(":scope > Item") : [];
      for (const child of children) {
        code += walkItem(child, varName, indent);
      }

      return code;
    }

    // Parse properties array to lines of luau
    function parseProps(props, varName) {
      const lines = [];
      for (const prop of props) {
        const name = prop.tagName;
        if (skipProps.includes(name)) continue;
        let val = prop.textContent.trim();

        // Convert types, enums, bool, etc
        if (name === "Vector3") {
          lines.push(`pcall(function() ${varName}.${name}=${toVector3(val)} end)`);
        } else if (name === "CFrame") {
          lines.push(`pcall(function() ${varName}.${name}=${toCFrame(val)} end)`);
        } else if (name === "Color3") {
          lines.push(`pcall(function() ${varName}.${name}=${toColor3(val)} end)`);
        } else if (name === "bool") {
          lines.push(`pcall(function() ${varName}.${name}=${val === "true"} end)`);
        } else if (name.match(/Enum\./)) {
          // TODO: enum parsing if needed
          lines.push(`pcall(function() ${varName}.${name}=${val} end)`);
        } else if (isNaN(Number(val))) {
          lines.push(`pcall(function() ${varName}.${name}="${val}" end)`);
        } else {
          lines.push(`pcall(function() ${varName}.${name}=${val} end)`);
        }
      }
      return lines;
    }

    // Format generic value for setting (strings get quotes, others raw)
    function formatValue(val) {
      if (typeof val === "string") {
        return `"${val.replace(/"/g, '\\"')}"`;
      }
      if (typeof val === "boolean") {
        return val ? "true" : "false";
      }
      return val;
    }

    // Sanitize variable names (remove spaces, punctuation, etc)
    function sanitizeName(name) {
      return name.replace(/[^a-zA-Z0-9_]/g, "") || "unnamed";
    }

    // Helpers for Roblox types from string values
    function toVector3(str) {
      const parts = str.split(" ");
      return `Vector3.new(${parts.join(",")})`;
    }
    function toCFrame(str) {
      const parts = str.split(" ");
      return `CFrame.new(${parts.join(",")})`;
    }
    function toColor3(str) {
      const parts = str.split(" ");
      return `Color3.new(${parts.join(",")})`;
    }
  </script>
</body>
</html>
