<!DOCTYPE html>
<html>
<head>
  <title>RBXMX to LuaU Converter</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    textarea { width: 100%; height: 300px; margin-top: 1em; }
    #console { color: red; margin-top: 1em; font-weight: bold; display: block; }
  </style>
</head>
<body>
  <h1>RBXMX to LuaU Converter</h1>
  <input type="file" id="file">
  <button id="convert">Convert</button>
  <strong id="console"></strong>
  <textarea id="code" readonly></textarea>

  <script>
    const skipProps = [
      "AttributesSerialize", "Color3uint8", "MaterialColors",
      "PhysicsGrid", "Tags", "Version", "LinkedSource", "ScriptGuid",
      "SmoothGrid"
    ];

    const nonCreatable = new Set([
      "Workspace", "Players", "Lighting", "ReplicatedFirst", "ReplicatedStorage",
      "ServerScriptService", "ServerStorage", "StarterGui", "StarterPack",
      "StarterPlayer", "Teams", "SoundService", "Chat", "LocalizationService",
      "TestService", "RunService", "HttpService", "TweenService", "Terrain",
      "TextService", "LogService", "InsertService", "ContentProvider",
      "PathfindingService", "CollectionService", "MemoryStoreService", "MessagingService"
    ]);

    let idCounter = 0;
    function generateName() {
      return `unnamed${++idCounter}`;
    }

    document.getElementById("convert").addEventListener("click", () => {
      const fileInput = document.getElementById("file");
      const output = document.getElementById("code");
      const consoleOut = document.getElementById("console");
      const file = fileInput.files[0];

      if (!file) {
        consoleOut.textContent = "No file selected.";
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const parser = new DOMParser();
          const xml = parser.parseFromString(reader.result, "text/xml");
          const root = xml.querySelector("roblox");

          if (!root) throw new Error("Invalid RBXMX file");

          let result = 'local v1,v2,v3,v4,v5=Instance.new,Vector2.new,UDim2.new,BrickColor.new,CFrame.new\nlocal v6=pcall\nlocal t,f=true,false\n\n';

          const mapping = new Map();

          function walk(item, parentName = null) {
            const className = item.getAttribute("class");
            const tagName = sanitizeName(item.getAttribute("name") || generateName());

            if (mapping.has(item)) return;
            mapping.set(item, tagName);

            let line = "";
            if (className === "Terrain") {
              line += `local ${tagName}=workspace.Terrain\n`;
            } else if (nonCreatable.has(className)) {
              line += `local ${tagName}=game:GetService(\"${className}\")\n`;
            } else {
              line += `local ${tagName}=v1(\"${className}\")\n`;
            }

            const props = Array.from(item.querySelector("Properties")?.children || []);
            const lines = parseProps(props, tagName);
            for (const propLine of lines) line += `${propLine}\n`;

            if (parentName) {
              line += `v6(function() ${tagName}.Parent=${parentName} end)\n`;
            }

            const children = item.querySelectorAll(":scope > Item");
            for (const child of children) {
              line += walk(child, tagName);
            }

            return line;
          }

          let fullCode = "";
          root.querySelectorAll(":scope > Item").forEach(item => {
            fullCode += walk(item);
          });

          output.value = result + fullCode.trim();
          consoleOut.textContent = "";
        } catch (err) {
          consoleOut.textContent = "Error: " + err.message;
          output.value = "";
        }
      };

      reader.onerror = () => {
        consoleOut.textContent = "Error reading file.";
        output.value = "";
      };

      reader.readAsText(file);
    });

    function sanitizeName(name) {
      return name.replace(/[^a-zA-Z0-9_]/g, "_");
    }

    function parseProps(props, varName) {
      const lines = [];
      for (const prop of props) {
        const name = prop.getAttribute("name");
        if (skipProps.includes(name)) continue;

        const text = prop.textContent.trim();
        switch (prop.tagName) {
          case "string":
          case "ProtectedString":
            lines.push(`v6(function() ${varName}.${name}=${JSON.stringify(text)} end)`);
            break;
          case "bool":
            lines.push(`v6(function() ${varName}.${name}=${text === "true" ? "t" : "f"} end)`);
            break;
          case "int":
          case "float":
          case "double":
            lines.push(`v6(function() ${varName}.${name}=${Number(text)} end)`);
            break;
          case "Vector2": {
            const [x2, y2] = text.split(/\s+/).map(Number);
            lines.push(`v6(function() ${varName}.${name}=v2(${x2},${y2}) end)`);
            break;
          }
          case "UDim2": {
            const [sx, ox, sy, oy] = text.split(/\s+/).map(Number);
            lines.push(`v6(function() ${varName}.${name}=v3(${sx},${ox},${sy},${oy}) end)`);
            break;
          }
          case "BrickColor":
            lines.push(`v6(function() ${varName}.${name}=v4(${Number(text)}) end)`);
            break;
          case "CoordinateFrame": {
            const nums = text.split(/\s+/).map(Number).filter(n => !isNaN(n));
            if (nums.length >= 3) {
              lines.push(`v6(function() ${varName}.${name}=v5(${nums.join(",")}) end)`);
            }
            break;
          }
          case "token":
            lines.push(`v6(function() ${varName}.${name}=${JSON.stringify(text)} end)`);
            break;
          case "BinaryString":
            break;
          default:
            break;
        }
      }
      return lines;
    }
  </script>
</body>
</html>
