<!DOCTYPE html>
<html>
<head>
  <title>RBXMX to LuaU Converter</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    textarea { width: 100%; height: 300px; margin-top: 1em; }
    #console { color: red; margin-top: 1em; font-weight: bold; display: block; }
  </style>
</head>
<body>
  <h1>RBXMX to LuaU Converter</h1>
  <input type="file" id="file">
  <button id="convert">Convert</button>
  <strong id="console"></strong>
  <textarea id="code" readonly></textarea>

  <script>
    const skipProps = [
      "AttributesSerialize", "Color3uint8", "MaterialColors",
      "PhysicsGrid", "Tags", "Version", "LinkedSource", "ScriptGuid",
      "SmoothGrid"
    ];

    const nonCreatable = new Set([
      "Workspace", "Players", "Lighting", "ReplicatedFirst", "ReplicatedStorage",
      "ServerScriptService", "ServerStorage", "StarterGui", "StarterPack",
      "StarterPlayer", "Teams", "SoundService", "Chat", "LocalizationService",
      "TestService", "RunService", "HttpService", "TweenService", "Terrain",
      "TextService", "LogService", "InsertService", "ContentProvider",
      "PathfindingService", "CollectionService", "MemoryStoreService", "MessagingService"
    ]);

    document.getElementById("convert").addEventListener("click", () => {
      const fileInput = document.getElementById("file");
      const output = document.getElementById("code");
      const consoleOut = document.getElementById("console");
      const file = fileInput.files[0];

      if (!file) {
        consoleOut.textContent = "No file selected.";
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const parser = new DOMParser();
          const xml = parser.parseFromString(reader.result, "text/xml");
          const root = xml.querySelector("roblox");

          if (!root) throw new Error("Invalid RBXMX file");

          let result = 'local v1,v2,v3,v4,v5=Instance.new,Vector2.new,UDim2.new,BrickColor.new,CFrame.new\nlocal v6=pcall local t,f=true,false\n\n';
          const varMap = new Map();
          let id = 1;

          function walk(item, parentVar) {
            const className = item.getAttribute("class");
            const name = sanitizeName(item.getAttribute("name") || `unnamed${id++}`);
            let code = "";
            let varLine = "";

            if (className === "Terrain") {
              varLine = `local ${name} = workspace.Terrain\n`;
            } else if (nonCreatable.has(className)) {
              varLine = `local ${name} = game:GetService("${className}")\n`;
            } else {
              varLine = `local ${name} = v1("${className}")\n`;
            }

            code += varLine;
            code += parseProps(item.querySelector("Properties"), name);

            item.querySelectorAll(":scope > Item").forEach(child => {
              code += walk(child, name);
            });

            if (parentVar) {
              code += `v6(function() ${name}.Parent = ${parentVar} end)\n`;
            }

            return code;
          }

          result += Array.from(root.children).filter(n => n.tagName === "Item").map(i => walk(i)).join("");

          consoleOut.textContent = "";
          output.value = result.trim();
        } catch (err) {
          consoleOut.textContent = "Error: " + err.message;
          output.value = "";
        }
      };

      reader.onerror = () => {
        consoleOut.textContent = "Error reading file.";
        output.value = "";
      };

      reader.readAsText(file);
    });

    function sanitizeName(name) {
      return name.replace(/[^a-zA-Z0-9_]/g, "_");
    }

    function parseProps(propsNode, varName) {
      if (!propsNode) return "";
      const props = Array.from(propsNode.children);
      let lines = "";

      for (const prop of props) {
        const name = prop.getAttribute("name");
        if (skipProps.includes(name)) continue;

        const text = prop.textContent.trim();
        switch (prop.tagName) {
          case "string":
          case "ProtectedString":
            lines += `v6(function() ${varName}.${name} = ${JSON.stringify(text)} end)\n`;
            break;
          case "bool":
            lines += `v6(function() ${varName}.${name} = ${text === "true" ? "t" : "f"} end)\n`;
            break;
          case "int":
          case "float":
          case "double":
            lines += `v6(function() ${varName}.${name} = ${Number(text)} end)\n`;
            break;
          case "Vector2": {
            const [x, y] = text.split(/\s+/).map(Number);
            lines += `v6(function() ${varName}.${name} = v2(${x}, ${y}) end)\n`;
            break;
          }
          case "UDim2": {
            const [sx, ox, sy, oy] = text.split(/\s+/).map(Number);
            lines += `v6(function() ${varName}.${name} = v3(${sx}, ${ox}, ${sy}, ${oy}) end)\n`;
            break;
          }
          case "BrickColor":
            lines += `v6(function() ${varName}.${name} = v4(${Number(text)}) end)\n`;
            break;
          case "CoordinateFrame": {
            const nums = text.split(/\s+/).map(Number).filter(n => !isNaN(n));
            if (nums.length >= 3) {
              lines += `v6(function() ${varName}.${name} = v5(${nums.join(", ")}) end)\n`;
            }
            break;
          }
          case "token":
            lines += `v6(function() ${varName}.${name} = ${JSON.stringify(text)} end)\n`;
            break;
          case "BinaryString":
            break; // Skip BinaryString
        }
      }

      return lines;
    }
  </script>
</body>
</html>
